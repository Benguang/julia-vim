" Vim filetype plugin file
" Language:	Julia
" Maintainer:	Carlo Baldassi <carlobaldassi@gmail.com>
" Last Change:	2011 dec 11

if exists("b:did_ftplugin")
	finish
endif
let b:did_ftplugin = 1

let s:save_cpo = &cpo
set cpo-=C

setlocal include="^\s*\%(reload\|include\)\>"
setlocal suffixesadd=.jl
setlocal comments=:#
setlocal commentstring=#=%s=#
setlocal cinoptions+=#1
setlocal define="^\s*macro\>"

" Comment the following line if you don't want operators to be
" syntax-highlightened
let g:julia_highlight_operators=1

" Support for LaTex-to-Unicode conversion as in the Julia REPL

" (The dictionary was generated from within Julia with the following code:
"  #  open("latex_symbols.vim","w") do f
"  #    println(f, "\" This file is autogenerated")
"  #    println(f, "let g:latex_symbols = {\n    \\ ", join([string("'", latex, "': '", unicode, "'") for (latex,unicode) in sort!(collect(Base.REPLCompletions.latex_symbols), by=x->x[1])], ",\n    \\ "), "}")
"  #  end
" )
exe "source " . join(split(expand("<sfile>:p"), '/', 1)[0:-2], '/') . "/latex_symbols.vim"

function! LaTeXtoUnicode_omnifunc(findstart, base)
    if a:findstart
        let cnum = col('.')
        let l = getline('.')
        let i = match(l[0:cnum-2], '\\[A-Za-z]\+$')
        if i == -1
            let i = -3
        endif
        return i
    else
        if has_key(g:latex_symbols, a:base)
            return [g:latex_symbols[a:base]]
        else
            return []
        end
    endif
endfunction

set omnifunc=LaTeXtoUnicode_omnifunc

let s:JuliaFallbackTabTrigger = "\u0091JuliaFallbackTab"

function! s:JuliaSetFallbackTab(s, k)
    let mmdict = maparg(a:s, 'i', 0, 1)
    if empty(mmdict)
        exe 'inoremap <buffer> ' . a:k . ' <Tab>'
        return
    endif
    let rhs = mmdict["rhs"]
    if rhs == '<Plug>JuliaTab'
        return
    endif
    let pre = '<buffer>'
    if mmdict["silent"]
        let pre = pre . '<silent>'
    endif
    if mmdict["expr"]
        let pre = pre . '<expr>'
    endif
    if mmdict["noremap"]
        let cmd = 'inoremap '
    else
        let cmd = 'imap '
    endif
    exe cmd . pre . ' ' . a:k . ' ' . rhs
endfunction

function! JuliaTab()
    let l = getline('.')
    let cnum = col('.')
    let i = LaTeXtoUnicode_omnifunc(1, '')
    if i >= 0
        let base = l[i : cnum-2]
        let uni = LaTeXtoUnicode_omnifunc(0, base)
        if empty(uni)
            let i = -3
        else
            let b = ''
            for j in range(len(base))
                let b = b . "\b"
            endfor
            return b . uni[0]
        endif
    endif
    if i < 0
        return s:JuliaFallbackTabTrigger
    endif
endfunction

function! s:JuliaSetTab(wait_vim_enter)
    if a:wait_vim_enter && !exists("g:jl_did_vim_enter")
        return
    endif
    let g:jl_did_vim_enter = 1
    call s:JuliaSetFallbackTab('<Tab>', s:JuliaFallbackTabTrigger)
    imap <buffer> <Tab> <Plug>JuliaTab
    imap <buffer><expr> <Plug>JuliaTab JuliaTab()
endfunction

function! JuliaUnsetTab()
    iunmap <buffer> <Tab>
    if empty(maparg("<Tab>", "i"))
        call s:JuliaSetFallbackTab(s:JuliaFallbackTabTrigger, '<Tab>')
    endif
    iunmap <buffer> <Plug>JuliaTab
    exe 'iunmap <buffer> ' . s:JuliaFallbackTabTrigger
endfunction

" try to postpone the first initialization as much as possible,
" by calling s:JuliaSetTab only at VimEnter or later
call s:JuliaSetTab(1)
autocmd VimEnter *.jl call s:JuliaSetTab(0)

let b:undo_ftplugin = "setlocal include< suffixesadd< comments< commentstring<"
	\ . " define< shiftwidth< expandtab< indentexpr< indentkeys< cinoptions< omnifunc<"
        \ . " | call JuliaUnsetTab()"
        \ . " | delfunction LaTeXtoUnicode_omnifunc | delfunction JuliaTab | delfunction JuliaUnsetTab"

if exists("loaded_matchit")
	let b:match_ignorecase = 0

	" note: beginKeywords must contain all blocks in order
	" for nested-structures-skipping to work properly
	let s:beginKeywords = '\<\%(function\|macro\|begin\|type\|immutable\|let\|do\|\%(bare\)\?module\|quote\|if\|for\|while\|try\)\>'
	let s:endKeyowrds = '\<end\>'

	" note: this function relies heavily on the syntax file
	function! JuliaGetMatchWords()
		let s:attr = synIDattr(synID(line("."),col("."),1),"name")
		if s:attr == 'juliaConditional'
			return s:beginKeywords . ':\<\%(elseif\|else\)\>:' . s:endKeyowrds
		elseif s:attr =~ '\<\%(juliaRepeat\|juliaRepKeyword\)\>'
			return s:beginKeywords . ':\<\%(break\|continue\)\>:' . s:endKeyowrds
		elseif s:attr == 'juliaBlKeyword'
			return s:beginKeywords . ':' . s:endKeyowrds
		elseif s:attr == 'juliaException'
			return s:beginKeywords . ':\<\%(catch\|finally\)\>:' . s:endKeyowrds
		endif
		return ''
	endfunction

	let b:match_words = 'JuliaGetMatchWords()'

	" we need to skip everything within comments, strings and
	" the 'end' keyword when it is used as a range rather than as
	" the end of a block
	let b:match_skip = 'synIDattr(synID(line("."),col("."),1),"name") =~ '
		\ . '"\\<julia\\%(ComprehensionFor\\|RangeEnd\\|QuotedBlockKeyword\\|InQuote\\|Comment[LM]\\|\\%(\\|[EILbB]\\|Shell\\)String\\|RegEx\\)\\>"'

	let b:undo_ftplugin = b:undo_ftplugin
            \ . " | unlet! b:match_words b:match_skip b:match_ignorecase"
            \ . " | delfunction JuliaGetMatchWords"
endif

if has("gui_win32")
	let b:browsefilter = "Julia Source Files (*.jl)\t*.jl\n"
        let b:undo_ftplugin = b:undo_ftplugin . " | unlet! b:browsefilter"
endif

let &cpo = s:save_cpo
unlet s:save_cpo
